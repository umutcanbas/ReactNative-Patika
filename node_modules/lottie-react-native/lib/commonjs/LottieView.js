"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnimatedLottieView = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactNative = require("react-native");
var _LottieAnimationViewNativeComponent = _interopRequireWildcard(require("./specs/LottieAnimationViewNativeComponent"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
const AnimatedNativeLottieView = _reactNative.Animated.createAnimatedComponent(_LottieAnimationViewNativeComponent.default);
const defaultProps = {
  source: undefined,
  progress: 0,
  speed: 1,
  loop: true,
  autoPlay: false,
  autoSize: false,
  enableMergePathsAndroidForKitKatAndAbove: false,
  cacheComposition: true,
  useNativeLooping: false,
  resizeMode: 'contain',
  colorFilters: [],
  textFiltersAndroid: [],
  textFiltersIOS: []
};

/**
 * View hosting the lottie animation.
 */
class AnimatedLottieView extends _react.default.PureComponent {
  constructor(props) {
    super(props);
    _defineProperty(this, "_lottieAnimationViewRef", void 0);
    _defineProperty(this, "onAnimationFinish", evt => {
      if (this.props.onAnimationFinish) {
        this.props.onAnimationFinish(evt.nativeEvent.isCancelled);
      }
    });
    this.play = this.play.bind(this);
    this.reset = this.reset.bind(this);
    this.pause = this.pause.bind(this);
    this.resume = this.resume.bind(this);
    this.onAnimationFinish = this.onAnimationFinish.bind(this);
    this._captureRef = this._captureRef.bind(this);
  }
  play(startFrame, endFrame) {
    _LottieAnimationViewNativeComponent.Commands.play(this._lottieAnimationViewRef, startFrame ?? -1, endFrame ?? -1);
  }
  reset() {
    _LottieAnimationViewNativeComponent.Commands.reset(this._lottieAnimationViewRef);
  }
  pause() {
    _LottieAnimationViewNativeComponent.Commands.pause(this._lottieAnimationViewRef);
  }
  resume() {
    _LottieAnimationViewNativeComponent.Commands.resume(this._lottieAnimationViewRef);
  }
  _captureRef(ref) {
    if (ref === null) {
      return;
    }
    this._lottieAnimationViewRef = ref;
    if (this.props.autoPlay === true) {
      this.play();
    }
  }
  render() {
    var _this$props$colorFilt;
    const {
      style,
      source,
      autoSize,
      autoPlay,
      duration,
      textFiltersAndroid,
      textFiltersIOS,
      ...rest
    } = this.props;
    const sourceName = typeof source === 'string' ? source : undefined;
    const sourceJson = typeof source === 'object' && !source.uri ? JSON.stringify(source) : undefined;
    const sourceURL = typeof source === 'object' && source.uri ? source.uri : undefined;
    const aspectRatioStyle = sourceJson ? {
      aspectRatio: source.w / source.h
    } : undefined;
    const styleObject = _reactNative.StyleSheet.flatten(style);
    let sizeStyle;
    if (!styleObject || styleObject.width === undefined && styleObject.height === undefined) {
      sizeStyle = autoSize && sourceJson ? {
        width: source.w
      } : _reactNative.StyleSheet.absoluteFill;
    }
    const speed = duration && sourceJson && source.fr ? Math.round(source.op / source.fr * 1000 / duration) : this.props.speed;
    const colorFilters = (_this$props$colorFilt = this.props.colorFilters) === null || _this$props$colorFilt === void 0 ? void 0 : _this$props$colorFilt.map(colorFilter => ({
      ...colorFilter,
      color: (0, _reactNative.processColor)(colorFilter.color)
    }));
    return /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      style: [aspectRatioStyle, sizeStyle, style]
    }, /*#__PURE__*/_react.default.createElement(AnimatedNativeLottieView, _extends({
      ref: this._captureRef
    }, rest, {
      colorFilters: colorFilters,
      textFiltersAndroid: textFiltersAndroid,
      textFiltersIOS: textFiltersIOS,
      speed: speed,
      style: [aspectRatioStyle, sizeStyle || {
        width: '100%',
        height: '100%'
      }, style],
      sourceName: sourceName,
      sourceJson: sourceJson,
      sourceURL: sourceURL,
      onAnimationFinish: this.onAnimationFinish,
      autoPlay: autoPlay
    })));
  }
}
exports.AnimatedLottieView = AnimatedLottieView;
_defineProperty(AnimatedLottieView, "defaultProps", defaultProps);
//# sourceMappingURL=LottieView.js.map